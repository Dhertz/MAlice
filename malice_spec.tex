\documentclass[a4, 11pt]{article}

\usepackage{a4, fullpage}
\usepackage[tmargin=2.5cm, lmargin=2.5cm, rmargin=2.5cm, bmargin=2.5cm]{geometry}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{textcomp}
\usepackage{underscore}

\titlespacing\section{0pt}{11pt}{-2pt}
\titlespacing\subsection{0pt}{2pt}{-2pt}

\setlength{\parskip}{8pt}
\setlength{\parindent}{0pt}
\setlist{nolistsep}

\begin{document}

\title{\huge{\emph{MAlice} Language Specification}}
\author{Owen Davies\\Daniel Hertz\\Charlie Hothersall-Thomas}
\date{\today}

\maketitle

\section*{Introduction}
This document outlines the specification of the \emph{MAlice} language, which we have written based on the provided sample programs and their corresponding outputs. We will look at the lexical structure of the language, give a somewhat formal definition of the language in Backaus-Naur Form, and discuss any semantic decisions we have made about the language.

\section*{Lexical Structure}
\subsection*{Types}
There are two primitive types in the \emph{MAlice} language:

\begin{itemize}
  \item \textbf{number} - a number is a two's complement 32-bit integer 
  primitive, with a range of \( -(2^{31}) \) to \( +(2^{31} - 1) \). 
  \item \textbf{letter} - a letter is an 8 bit character primitive, which 
  allows scope for any character from the ASCII set.
\end{itemize}

\subsection*{Reserved Keywords}
The following table shows the list of keywords that cannot be used within a program, as they are keywords in the \emph{MAlice} language:

\begin{itemize}
  \item \textbf{and} - this keyword is a statement separator. See the \textbf{Delimiters} section.
  \item \textbf{ate} - this keyword increments a previously declared variable.
  \item \textbf{became} - this keyword allows assignment to a declared variable.
  \item \textbf{but} - see \textbf{and}.
  \item \textbf{closed} - this keyword marks the end of a program.
  \item \textbf{drank} - this keyword decrements a previously declared variable.
  \item \textbf{letter} - this is a primitive. See the \textbf{Types} section above.
  \item \textbf{opened} - this keyword marks the opening of a program.
  \item \textbf{number} - this is a primitive. See the \textbf{Types} section above.
  \item \textbf{said} - this is used along with \textquoteleft Alice\textquoteright{} to output values.
  \item \textbf{then} - see \textbf{and}.
  \item \textbf{too} - this keyword can follow a variable declaration as long as a variable has been declared directly before it and that variable was of the same type as the variable currently being declared.
  \item \textbf{was} - this keyword is used along with \textquoteleft \textbf{a}\textquoteright{} (and a type) to declare variables.
\end{itemize}

\subsection*{White Space}
White space is completely ignored and spacing is not important. Lines of \emph{MAlice} code are separated by delimiters - see the \textbf{Delimiters} section for more information on this.

\subsection*{Operators}
This table shows the operators that can be used in the language. It also shows the level of precedence of the operator.

\begin{center}
  \begin{tabular}{| c | c | c |}
  \hline
  \textbf{Operation}&\textbf{Symbol}&\textbf{Precedence Level}\\
  \hline
  Addition         & +                     & 2 \\
  Bitwise AND      & \&                    & 3 \\
  Bitwise NOT      & \( \sim \)            & 0 \\
  Bitwise OR       & \textbar              & 4 \\
  Bitwise XOR      & \( \wedge \)          & 5 \\
  Decrement        & \texttt{drank}        & 0 \\
  Increment        & \texttt{ate}          & 0 \\
  Integer Division & \textfractionsolidus  & 1 \\
  Modulo           & \%                    & 1 \\
  Multiplication   & \textasteriskcentered & 1 \\
  \hline
  \end{tabular}
\end{center}

All operators are binary, apart from \textbf{Bitwise NOT}, \textbf{Increment} and \textbf{Decrement} which are unary. The \textbf{Bitwise NOT} opertor is used on the left-hand side of the operand; the other two are used on the right (and require a space after the operand).

\section*{Semantic Decisions}
\subsection*{Delimiters}
There are 2 main categories of delimiters in \emph{MAlice} - ones that end lines, and ones that combine multiple lines into one. Full stops and commas separate lines, while the keywords \textquoteleft \textbf{and}\textquoteright , \textquoteleft \textbf{but}\textquoteright{} and \textquoteleft \textbf{then}\textquoteright{} connect two lines together. As whitespace is removed at compile time, there can be as many delimiters as necessary on a single line in the source file.

\subsection*{Variable Name Constraints}
Variable names must begin with either a lower- or upper-case letter. Underscores are allowed, provided that they are not the first or last chacter of the variable name. Capital letters can follow an underscore character, but all other characters must be lower case. These constraints have been modelled on the English language, which matches the overall aim of \emph{MAlice} to read like a natural language. These constraints can be represented by the below regular expression:

\begin{center}
  \texttt{[A-Za-z](_[A-Za-z]|[a-z])*}
\end{center}

\section*{Backaus-Naur Form Grammar}
The following grammar gives the grammar for a valid \emph{MAlice} program. We have used the Extended BNF syntax, as this allows us to express the grammar for expressions, declarations and assignments much more succinctly.\\
\begin{verbatim}
      <program> ::= "The" "looking-glass" "hatta" "()" "opened" 
                    <statementList> "closed"
<statementList> ::= <statement> <delimiter> <statement-list> | <printReturn>
  <printReturn> ::= <expression> "said" "Alice."
    <statement> ::= <declaration> | <assignment> | <step>
  <declaration> ::= (<ID> "was" "a" <TYPE>) ("too"?)
   <assignment> ::= <ID> "became" (<expression> | <CHAR>)
         <step> ::= <ID> ("drank" | "ate")
   <expression> ::= <or> ("^" <or>)*
           <or> ::= <and> ("|" <and>)*
          <and> ::= <add> ("&" <add>)*
          <add> ::= <ones> ("+" <ones>)*
         <ones> ::= <term> (("/" | "*" | "%") <term>)*
         <term> ::= ("~" term) | <ID> | <INT>
         
           <ID> ::= see regular expression in section above
         <CHAR> ::= '("a".."z")'
          <INT> ::= "0".."9"+
         <TYPE> ::= "letter" | "number"
\end{verbatim}\\
We have removed the left recursion from the \texttt{<expression>} rule by breaking the rule up into several sub rules. We have one rule for each level of operator precedence, which allows us to easily define the precedence rules within the grammar (the higher precedence operators are \textquoteleft closer\textquoteright{} to the \texttt{<term>} in the expression, with the \textbf{Binary NOT} rule being the closest as it has a precedence of 0). The \textbf{drank} and \textbf{ate} operators have been broken away into a seperate \texttt{<step>} rule, since they must be on their own in a statement and come after the operand. 

\end{document}
