grammar MAliceold;

options
{
  language = Cpp;
}


// Turns out we need these things to actually build C++ properly:
// The Parser requires the Lexer as an include
@parser::includes
{
   #include "MAliceoldLexer.hpp"
}

// This is namespace that is generated, for use in everything
@lexer::namespace { MAliceold }
@parser::namespace{ MAliceold }

// This is needed but I've left it as default because I don't know what it does!
@lexer::traits
{
  class MAliceoldLexer;
  class MAliceoldParser;
  typedef antlr3::Traits< MAliceoldLexer, MAliceoldParser > MAliceoldLexerTraits;
  typedef MAliceoldLexerTraits MAliceoldParserTraits;
}


program: declarationList EOF;
declarationList : (declaration)+;

declaration: varDeclaration | funcDeclaration | procDeclaration;// | COMMENT;

varDeclaration: (ID 'was' 'a' type (('too' | 'of' expression)?) delimiter) |
                (ID 'had' expression type delimiter);

funcDeclaration: 'The' 'room' ID headerParams 'contained' 'a' type body;

procDeclaration: 'The' 'looking-glass' ID headerParams /*(COMMENT?)*/ body;

headerParams: '(' (headerParamsList)? ')';
headerParamsList: (headerParam) (',' headerParam)*;

headerParam: (type | refType) ID;

callParams: '(' (callParamsList?) ')';
callParamsList: expression (',' expression)*;

body: 'opened' ((declarationList?) statementList | ) 'closed';

statementList: (statement)+;

idOperations: 'became' expression | 'ate' | 'drank';

statement: body |
           ID ('\'' 's' expression 'piece')? (('said' 'Alice' | 'spoke') | callParams (('said' 'Alice')?) | idOperations) delimiter |
           (STRING | CHAR | INT) ('said' 'Alice' | 'spoke') delimiter |
           'Alice' 'found' expression '.' |
           'what' 'was' expression '?' (delimiter?) |
           'eventually' '(' expression ')' 'because' statementList 'enough' 'times' (delimiter?) |
           'either' '(' expression ')' 'so' statementList 'or' statementList 'because' 'Alice' 'was' 'unsure' 'which' (delimiter?) |
           conditionalStatement ('or' statementList)? 'because' 'Alice' 'was' 'unsure' 'which' (delimiter?);/* |
           COMMENT;*/
           
conditionalStatement: ('perhaps' '(' expression ')' 'so' statementList) ('or' 'maybe' '(' expression ')' 'so' statementList)*;

type: 'number' | 'letter' | 'sentence';
refType: 'spider' type;

expression: (prec10 ('||' prec10)*);
prec10:	prec9 ('&&' prec9)*;
prec9: prec8 ('|' prec8)*;
prec8: prec7 ('^' prec7)*;
prec7: prec6 ('&' prec6)*;
prec6: prec5 (('==' | '!=') prec5)*;
prec5: prec4 (('>' | '<' | '>=' | '<=') prec4)*;
prec4: prec3 (('+' | '-') prec3)*;
prec3: prec2 (('*' | '/' | '%') prec2)*;
prec2: ('!' | '~' | '+' | '-')? atom;

atom: ID ('\'' 's' expression 'piece' | callParams | ) | '\'' CHAR '\'' |
      STRING | INT | '(' expression ')';

delimiter: '.' | ',' | 'and' | 'but' | 'then';
ID: ('a'..'z'|'A'..'Z') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*;
STRING:	'"' (~'"')* '"';
INT: ('0'..'9')+;

// Maybe add in more characters later
CHAR: ('a'..'z'|'A'..'Z'|'_');

// COMMENT: '###' ~( '\r' | '\n')*;
